package paulojjj.solarenergy.blocks;

import java.util.List;

import net.minecraft.block.Block;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.material.Material;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.fluid.IFluidState;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.CompoundNBT;
import net.minecraft.state.DirectionProperty;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.ActionResultType;
import net.minecraft.util.Direction;
import net.minecraft.util.Hand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.BlockRayTraceResult;
import net.minecraft.world.IBlockReader;
import net.minecraft.world.World;
import net.minecraft.world.storage.loot.LootContext.Builder;
import net.minecraft.world.storage.loot.LootParameters;
import net.minecraftforge.common.extensions.IForgeBlock;
import paulojjj.solarenergy.NBT;
import paulojjj.solarenergy.Tier;
import paulojjj.solarenergy.gui.GuiHandler;
import paulojjj.solarenergy.gui.GuiHandler.GUI;
import paulojjj.solarenergy.tiles.BatteryTileEntity;


public class Battery extends Block implements IForgeBlock {
	
	private DirectionProperty FACING = DirectionProperty.create("facing");

	private Tier tier;

	public Battery(Tier tier) {
		super(Block.Properties.create(Material.ROCK).hardnessAndResistance(3.5f, 50.0f));
		setDefaultState(this.getDefaultState().with(FACING, Direction.NORTH));
		this.tier = tier;
	}

	@Override
	public boolean hasTileEntity(BlockState state) {
		return true;
	}

	@Override
	public TileEntity createTileEntity(BlockState state, IBlockReader world) {
		return new BatteryTileEntity(tier);
	}

	@Override
	public BlockRenderType getRenderType(BlockState state) {
		return BlockRenderType.MODEL;
	}

	@Override
	protected void fillStateContainer(net.minecraft.state.StateContainer.Builder<Block, BlockState> builder) {
		super.fillStateContainer(builder);
		builder.add(FACING);
	}

	@Override
	public List<ItemStack> getDrops(BlockState state, Builder builder) {
		@SuppressWarnings("deprecation")
		List<ItemStack> drops = super.getDrops(state, builder);
		
		BatteryTileEntity te = (BatteryTileEntity)builder.get(LootParameters.BLOCK_ENTITY);
		ItemStack stack = drops.iterator().next();
		CompoundNBT nbt = new CompoundNBT();
		stack.setTag(nbt);
		nbt.putDouble(NBT.ENERGY, te.getUltraEnergyStored());
		nbt.putDouble(NBT.MAX_ENERGY, te.getMaxUltraEnergyStored());
		
		return drops;
	}

	@Override
	public void onBlockPlacedBy(World worldIn, BlockPos pos, BlockState state, LivingEntity placer,
			ItemStack stack) {
		super.onBlockPlacedBy(worldIn, pos, state, placer, stack);
		CompoundNBT nbt = stack.getTag();
		if(nbt != null) {
			double energy = nbt.getDouble(NBT.ENERGY);
			double maxEnergy = nbt.getDouble(NBT.MAX_ENERGY);
			BatteryTileEntity te = (BatteryTileEntity)worldIn.getTileEntity(pos);
			te.setUltraEnergyStored(energy);
			te.setMaxUltraEnergyStored(maxEnergy);
		}
        
        Direction facing = placer.getHorizontalFacing().getOpposite();
        int height = Math.round(placer.rotationPitch);
        if (height >= 65) {
        	facing = Direction.UP;
        } else if (height <= -30) {
        	facing = Direction.DOWN;
        }
		worldIn.setBlockState(pos, state.with(FACING, facing));
	}	

	/*	@Override
	public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) {
		worldIn.getClosestPlayer(pos.get, posY, posZ, distance, spectator)
		// TODO Auto-generated method stub
		super.onBlockAdded(worldIn, pos, state);
	}*/


	@Override
	public ActionResultType onBlockActivated(BlockState state, World worldIn, BlockPos pos, PlayerEntity player, Hand handIn, BlockRayTraceResult hit) {
		if(worldIn.isRemote) {
			return ActionResultType.PASS;
		}
		if(player.isCrouching()) {
			worldIn.setBlockState(pos, state.with(FACING, hit.getFace()));
			return ActionResultType.PASS;
		}
		GuiHandler.openGui(player, worldIn, GUI.BATTERY, pos);
		return ActionResultType.CONSUME;
	}
	
	@Override
	public void neighborChanged(BlockState state, World worldIn, BlockPos pos, Block blockIn, BlockPos fromPos,
			boolean isMoving) {
		if(!worldIn.isRemote) {
			BatteryTileEntity tileEntity = (BatteryTileEntity)worldIn.getTileEntity(pos);
			tileEntity.onNeighborChanged(fromPos);
		}
	}

	@Override
	public boolean removedByPlayer(BlockState state, World world, BlockPos pos, PlayerEntity player,
			boolean willHarvest, IFluidState fluid) {
		//Delay deletion of the block until after getDrops
		if(willHarvest) return true;
		return super.removedByPlayer(state, world, pos, player, willHarvest, fluid);
	}

	
	@Override
	public void harvestBlock(World worldIn, PlayerEntity player, BlockPos pos, BlockState state, TileEntity te,
			ItemStack stack) {
		super.harvestBlock(worldIn, player, pos, state, te, stack);
		worldIn.removeBlock(pos, false);
	}


}
